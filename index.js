var util = require('util');
var _ = require('underscore');
var request = require('request');

var Charon = module.exports = {};

// Defines a Client type and returns an instance of it.
// ``overrides``: Object, optional prototype properties to add to the client
//                definition.
// Example:
//    var MyClient = Charon.ClientFactory({
//      initialize: function (options) {
//        this.special = true;
//        Charon.Client.initialize.apply(this, arguments);
//      }
//    });
Charon.ClientFactory = function (overrides) {
  var ClientCtor = overrides ? Charon.Client.extend(overrides) : Charon.Client;
  return new ClientCtor();
};

// Creates a child of ``this`` constructor, optionally with additional
// prototype and constructor properties.
// Preserves inheritance chain for use of ``instanceof``.
// Child constructors contain a reference to ``extend``, and prototypes
// include a valid ``constructor`` reference.
// Example:
//   var MyErrorType = extend.call(Error, { name: 'MyErrorType' });
var extend = function extend (prototypeProperties, constructorProperties) {
  // unpack args: default empty objects
  prototypeProperties || (prototypeProperties = {});
  constructorProperties || (constructorProperties = {});
  // end unpack args
  var parent = this;
  // constructor may be defined in prototypeProperties:
  var child = _.has(prototypeProperties, 'constructor') ?
    prototypeProperties.constructor :
    function () { parent.apply(this, arguments); };
  util.inherits(child, parent); // extend prototype from parent to child
  // Add constructor properties from parent and params. Set ``extend``
  // reference as well in case it is not defined on parent.
  _.extend(child, parent, constructorProperties, { extend: extend });
  // Add prototype properties from params. Set ``constructor`` reference too
  // because not all clients do this automatically.
  _.extend(child.prototype, prototypeProperties, { constructor: child });
  return child;
};

var errors = {};

// Abstract base error constructor. All errors generated by Charon
// should test positive as ``instanceof`` this constructor, but in practice
// all errors are actually created using a more specific error defined below.
// ``message``: optional string describing the problem. Intended for debugging.
// ``data``: optional object with more information about the error
errors.Error = extend.call(Error, {
    constructor: function CharonError (message, data) {
      // unpack args: message and data are both optional
      // if first arg is an object, assume ``message`` was omitted and
      // first arg is actually ``data``
      if (_.isObject(message)) {
        data = message;
        message = undefined;
      }
      // end unpack args
      if (data) {
        if (_.isObject(data)) {
          this.data = data;
        }
        else {
          this.data = {
            constructorError: "invalid error data type: " + typeof data,
            originalData: data
          };
        }
      }
      this.message = message ? message.toString() : '';
    },
    name: "Charon.Error"
  },
  {
    isCharonErrorConstructor: true
  });

// Indicates a problem which in usage may be resolved by the consumer, e.g.,
// 4xx, invalid data, unauthorized user.
errors.ConsumerError = errors.Error.extend({ name: 'Charon.ConsumerError' });
// Indicates a problem somewhere in the service or one of its components, e.g.,
// 5xx, unhandled exception, service unavailable). Note, in this context, the
// "service" includes the client through which the service is invoked.
// Basically, any problem that is not due to usage is a "Service Error".
errors.ServiceError = errors.Error.extend({ name: 'Charon.ServiceError' });

// Error subtypes. These errors are derived from the two basic error types
// defined above. They are provided here in order to help applications present
// more accurate and helpful information to end users, but their usage is not
// required within an integration.

// the service understands the request but refuses to fulfill it
errors.RequestForbiddenError = errors.ConsumerError.extend({ name: 'Charon.RequestForbiddenError' });
// the service cannot find the requested resource
errors.ResourceNotFoundError = errors.ConsumerError.extend({ name: 'Charon.ResourceNotFoundError' });
// the service cannot fulfill the request at this time due to a resource conflict
errors.ResourceConflictError = errors.ConsumerError.extend({ name: 'Charon.ResourceConflictError' });
// Unexpected programming error (e.g., unhandled exception)
errors.RuntimeError = errors.ServiceError.extend({ name: 'Charon.RuntimeError' });
// Failure to parse service response. Generally indicates bad format.
errors.ParseError = errors.ServiceError.extend({ name: 'Charon.ParseError' });
// Service did not complete within specified timeout period
errors.TimeoutError = errors.ServiceError.extend({ name: 'Charon.TimeoutError' });

// supply a reference to all errors in the Charon library
_.extend(Charon, errors);


// A client contains configuration options and one or more resource managers.
// This constructor is an internal implementation detail; integrators are
// expected to define client singletons using the ``Charon.ClientFactory``.
Charon.Client = extend.call(Function, _.extend({},
  errors, // supply a reference to all errors in Client instances
  {
    constructor: function Client () {
      // set self-reference
      this.client = this;
      // wrap initialization method to toggle state flag and return self ref
      this.initialize = _.wrap(this.initialize,
        _.bind(function (origInitialize) {
          origInitialize.apply(this, _.rest(arguments, 1));
          this.isInitialized = true;
          return this;
        }, this)
      );
    },

    // Initializes the Client instance. Intended to be run just once, at
    // time of app bootstrap / initialization.
    // ``options`` (object): The properties in this object will be applied
    //                       to the instance properties.
    // May be overridden by the integrator.
    initialize:  function (options) {
      _.extend(this, options);
    },

    // A simple flag to keep track of initialization state
    isInitialized: false,

    // Logs the specified data.
    // Intended as a logging-lib-agnostic layer, allowing for isomorphic
    // clients with logging abilities.
    // Defaults to noop.
    // May be overridden by the integrator.
    log: function (level, message, obj) {},

    // Internal helper function used to pass ``err``, ``data`` to ``next``.
    // Just some centralized boilerplate that provides the following features:
    //  - ensures ``err``, ``data`` always present
    //  - passed undefined instead of ``data`` if ``err`` is present
    //  - invokes ``next`` callback in context of ``this``
    invokeNext: function (err, data, next) {
      var args = [err];
      if (err) { args.push(undefined); }
      else if (! err) { args.push(data); }
      next.apply(this, args);
    },

    // Internal helper function used to create function wrappers.
    // Like _.wrap, except for the following differences:
    //  - wrapped ``callback`` function is last argument, as per convention
    //  - ``wrapper`` is expected to take ``callback`` function last, as per
    //    convention.
    //  - returned function is bound to ``this`` instance.
    // Expects the following arguments:
    // ``callback`` (function): function to be wrapped
    // ``wrapper`` (function): wrapper function responsible for executing
    //        ``callback`` with appropriate arguments. Accepts these arguments:
    //    ``arguments`` - should accept all the arguments of ``callback``
    //    ``callback`` (function): wrapped function
    wrap: function wrap (wrapper, callback) {
      return _.bind(function wrapped () {
        var args = _.toArray(arguments).concat([callback]);
        return wrapper.apply(this, args);
      }, this);
    },

    // A response middleware function. Attempts to detect errors
    // in the ``responseSpec`` and create appropriate error instances to pass
    // to the ``next`` callback as necessary.
    // This logic should be common for most APIs, but it may be overidden
    // by the integrator if so desired.
    detectErrors: function detectErrors (err, responseSpec, next) {
      var callbackErr;
      if (err) {
        callbackErr = err;
      }
      else {
        var status = responseSpec.statusCode;
        if (status == 403) {
          callbackErr = new Charon.RequestForbiddenError(responseSpec);
        }
        else if (status == 404) {
          callbackErr = new Charon.ResourceNotFoundError(responseSpec);
        }
        else if (status == 409) {
          callbackErr = new Charon.ResourceConflictError(responseSpec);
        }
        else if (status >= 400 && status <= 499) {
          // 4xx error
          callbackErr = new Charon.ConsumerError(responseSpec);
        }
        else if (status >= 500 && status <= 599) {
          // 5xx error
          callbackErr = new Charon.ServiceError(responseSpec);
        }
        else if (! (status >= 200 && status <= 299)) {
          // not sure what this is, but it's not successful
          callbackErr = new Charon.RuntimeError('Unrecognized HTTP status code', responseSpec);
        }
      }
      this.invokeNext(callbackErr, responseSpec, next);
    },

    // creates the context used when substituting values in a URL template
    makeUrlTemplateContext: function (data, options) {
      return _.extend({}, this.client, data, options);
    },

    // Substitutes template placeholders in a URL with actual values.
    // URL placeholders may be specified in the form ``:name``, where "name"
    // is the name of a property in the ``data`` or ``options`` object.
    // This feature is provided as a shortcut for simple usecases and for
    // compatibility with services such as Restify and Express. If it does
    // not meet your needs, you should define a custom url getter function.
    templateUrl: function (url, data, options) {
      var urlTemplateRegex = /:([a-zA-Z_$][\w_$]*)/;
      var templateContext = this.makeUrlTemplateContext(data, options);
      var matches = urlTemplateRegex.exec(url);
      // limit to 100 to avoid runaway recursion
      for (var i = 0; matches && i < 100; i++) {
        url = url.replace(matches[0], templateContext[matches[1]] || '');
        matches = urlTemplateRegex.exec(url);
      }
      return url;
    },

    // A network-communication-lib adapter. Responsible for invoking
    // the callback with the following params:
    //  - ``err``: a CharonError instance or null/undefined
    //  - ``responseSpec``: a normalized response specification object. Should
    //                  contain the following properties:
    //    - ``statusCode``: the HTTP status code
    //    - ``body``: the response entity.
    //    - ``headers``: the response headers
    //    - ``requestSpec``: the request specification object
    // This default implementation is compatible with the request lib
    // (https://npmjs.org/package/request).
    // May be overridden by the integrator for compatibility with a different
    // network communication lib API.
    submitRequest: function submitRequest (requestSpec, callback) {
      request({
        json: requestSpec.body || true,
        url: requestSpec.url,
        method: requestSpec.method,
        headers: requestSpec.headers,
        timeout: requestSpec.timeout
      }, _.bind(function (err, response, body) {
        var callbackErr, responseSpec;
        if (err) {
          if (err.code && err.code.indexOf("TIMEDOUT") !== -1) {
            callbackErr = new Charon.TimeoutError(
              "Timeout after " + requestSpec.timeout + "ms", {
                err: err,
                requestSpec: requestSpec
              });
          }
          else {
            callbackErr = new Charon.RuntimeError('HTTP client error', {
              err: err,
              requestSpec: requestSpec
            });
          }
        }
        else {
          responseSpec = {
            body: body,
            statusCode: response.statusCode,
            headers: response.headers,
            requestSpec: requestSpec
          };
          // The request lib silently fails on JSON parse errors.
          // We should make parse failures explicit in order to "communicate
          // bad news as soon as possible and in as much detail as possible".
          // Note, This error-checking code will give a false positive for
          // JSON-serialized string response bodies, because those strings will
          // have already been parsed by the Request lib. However, String
          // response bodies are not a common use-case for JSON entities.
          if (_.isString(body)) {
            var responseType = response.headers['content-type'];
            if ((responseType || '').indexOf('application/json') === 0) {
              // resource indicates JSON but body is not parsed
              try {
                responseSpec.body = JSON.parse(responseSpec.body);
              }
              catch (e) {
                callbackErr = new Charon.ParseError(
                  'Failed to parse resource identified as JSON',
                  {
                    err: e,
                    responseSpec: responseSpec
                  });
              }
            }
          }
        }
        this.invokeNext(callbackErr, responseSpec, callback);
      }, this));
    },

    // Defines a ResourceManager type and returns an instance of it.
    // ``overrides``: Object, optional prototype properties to add to the
    //                resource manager definition.
    // Example:
    //    MyClient.Resource = MyClient.ResourceManagerFactory({
    //      url: "/resource"
    //    });
    ResourceManagerFactory: function (overrides) {
      var ResourceManagerCtor = overrides ? Charon.ResourceManager.extend(overrides) : Charon.ResourceManager;
      return new ResourceManagerCtor(this);
    },

    // Methods that do not include a request body by default. This is shared
    // by all resource managers and service calls within a client.
    bodyExclusionMethods: ['GET', 'HEAD'],

    // The following service call parameters may defined as defaults
    // at the client or resource manager level and overridden by the service
    // call definition.
    serviceCallParams: [
      "parseResource", "responseMiddleware",
      // The following request specification params may be defined as either
      // static values or as functions which return the appropriate value.
      "url", "method", "headers", "body", "timeout"
    ],

    // default URL.
    // URL is a required param and is not defined by default.
    url: undefined,

    // default request method.
    method: "GET",

    // default request headers.
    // defaults to no headers.
    headers: undefined,

    // default request body.
    // defaults to returning first arg to service call.
    body: function (data, options) {
      return data;
    },

    // default timeout period.
    // defaults to disabled
    timeout: undefined,

    // default resource parser.
    // Executes after all callback wrappers. Responsible for parsing the
    // resource from the response and passing ``err``, ``resource`` to the
    // next callback.
    parseResource: function parseResource (err, responseSpec, next) {
      var resource = responseSpec ? responseSpec.body : undefined;
      this.invokeNext(err, resource, next);
    },

    // default response middleware.
    // May be used for common error handling, logging, etc., or may be disabled
    // by simply acting as a pass-through.
    // Responsible for passing ``err``, ``resourceSpec`` to ``next``.
    responseMiddleware: function responseMiddleware (err, responseSpec, next) {
      this.detectErrors(err, responseSpec, next);
    }

  }), {
    isCharonClientConstructor: true
  });



// A resource manager is essentially a container for several services that act
// on a common resource type. A resource manager is tied at the belt to a
// specific client instance, but its behavior may be modified from the
// client defaults by changing the properties of the resource manager.
Charon.ResourceManager = extend.call(Function,
  {
    // ``client`` (object): CharonClient instance
    constructor: function ResourceManager (client) {
      this.linkClient(client);
    },

    // links the resource manager instance to the client
    // ``client`` (object): CharonClient instance
    linkClient: function (client) {
      this.client = client;
      for (var propertyName in client) {
        this.linkClientProperty(propertyName);
      }
    },

    // links a single property from the client (identified by ``propertyName``
    // to ``this`` instance
    linkClientProperty: function (propertyName) {
      var value = this.client[propertyName];
      if (! _.isUndefined(this[propertyName])) {
        // pass, defer to resource manager prototype properties
      }
      else if (_.isFunction(value)) {
        // copy functions (including the error ctors) by direct reference
        this[propertyName] = value;
      }
      else if (_.contains(this.client.serviceCallParams, propertyName)) {
        // default service call params which are not function values are proxied
        // via getter functions
        this[propertyName] = function () { return this.client[propertyName]; };
      }
      // all other properties are assumed to be client configuration, and
      // should be accessed by referencing the ``client`` instance property.
    },

    // Function factory which defines a service call.
    // A "service call" is an abstraction around a RESTful service, and the
    //  means by which a client user may make a request to the service and
    //  receive a response.
    // ``serviceCallDefinitionParams`` (object): factory params
    // Some parameter properties may be either a static value, or a getter
    // function. Getters are called in the context of the resource manager,
    // and get passed the service call's ``data`` and ``options`` arguments.
    //  - ``url`` (string or function): returns a fully qualified Uniform
    //                       Resource Locator.
    //  - ``method`` (string or function): returns an HTTP method. Optional.
    //  - ``headers`` (object or function): returns a map of HTTP header names
    //                       to values.
    //  - ``body`` (object or function): returns a JSON-serializable request
    //                       entity object.
    //  - ``timeout`` (int or function): A time period, in milliseconds, after
    //                       which the request should be aborted and an error
    //                       should be passed to the callback.
    //  - ``responseMiddleware`` (function): Response handler middleware function.
    //                       Should invoke the ``next`` callback, passing error
    //                       and responseSpec object. Accepts arguments:
    //    - ``err`` (object): CharonError instance or falsey
    //    - ``responseSpec`` (object): response specification object
    //    - ``next`` (function): callback function
    //  - ``parseResource`` (function): Resource parser middleware function.
    //                       Should invoke the ``next`` callback, passing error
    //                       and parsed resource object. Accepts arguments:
    //    - ``err`` (object): CharonError instance or falsey
    //    - ``responseSpec`` (object): response specification object
    //    - ``next`` (function): callback function
    defineServiceCall: function (serviceCallDefinition) {
      // unpack params
      var params = _.clone(serviceCallDefinition || {});
      // apply default values
      _.each(this.client.serviceCallParams, function (paramName) {
        params[paramName] || (params[paramName] = this[paramName]);
      }, this);
      // end unpack params

      // define service call function:
      var serviceCall = function ServiceCall (data, options, callback) {
        // unpack params
        // both data and options may be omitted; accept single callback param
        if (_.isFunction(data)) {
          callback = data;
          data = undefined;
          options = undefined;
        }
        // options may be singly omitted; accept shifted params
        else if (_.isFunction(options)) {
          callback = options;
          options = undefined;
        }
        // apply default values
        data || (data = {});
        options || (options = {});
        callback || (callback = function () {});
        // end unpack params
        if (! this.client.isInitialized) {
          callback(new Charon.RuntimeError("Client is not initialized"));
        }
        var getValue = _.bind(function (param) {
          return _.isFunction(param) ? param.call(this, data, options) : param;
        }, this);

        var method = getValue(params.method);
        var body;
        if (! _.contains(this.client.bodyExclusionMethods, method)) {
          body = getValue(params.body);
        }
        var requestSpec = {
          url: this.templateUrl(getValue(params.url), data, options),
          method: method,
          headers: getValue(params.headers),
          body: body,
          timeout: getValue(params.timeout)
        };

        // convert response to resource before invoking callback
        var responseHandler = this.wrap(params.parseResource, callback);
        // let response middleware do whatever it does before invoking callback
        responseHandler = this.wrap(params.responseMiddleware, responseHandler);

        this.submitRequest(requestSpec, responseHandler);
      };
      return serviceCall;
    },

    // Defines multiple service calls and assigns to properties on this
    // instance.
    // ``serviceCallDeclaration`` (object): map of instance property names to
    // service call definition parameters. See
    // ``Charon.ResourceManager.defineServiceCall`` for more information on
    // expected params.
    declareServiceCalls: function (serviceCallDeclaration) {
      _.each(serviceCallDeclaration, function (definitionParams, name) {
        this[name] = this.defineServiceCall(definitionParams);
      }, this);
    }

  }, {
    isCharonResourceManagerConstructor: true
  });
