var url = require('url');
var util = require('util');

var async = require('async');
var requestLib = require('request');
var _ = require('underscore');

var DEFAULT_BASE_URL = 'http://';

/** 
  * A little library to ease developing API clients.
  * Mostly focused on abstracting away the nitty gritty aspects of HTTP.
  * Also provides some link traversal goodies.
  * @namespace
  * @author Sam Placette
  */
var Charon = module.exports = {};

/**
  * Creates an extension of the constructor in context, optionally
  * with additional prototype and constructor properties.
  * Preserves inheritance chain for use of `instanceof`.
  * Extensions contain a reference to {@link extend}, and prototypes
  * include a valid `constructor` reference.
  * @memberof Charon
  * @inner
  * @this Constructor
  * @param {Object} [prototypeProperties={}] - Properties to apply to the
  * extension prototype
  * @param {Object} [constructorProperties={}] - Properties to apply to the
  * constructor reference itself ("static" or "class" properties).
  * @returns {Function} Extended constructor
  * @example
  * var MyErrorType = extend.call(Error,
  *    { name: 'MyErrorType' },
  *    { isMyErrorType: true });
  * MyErrorType.isMyErrorType // true
  * (new MyErrorType()).name // "MyErrorType"
  * (new MyErrorType()) instanceof Error // true
  */
var extend = function extend (prototypeProperties, constructorProperties) {
  // Unpack args: default empty objects
  prototypeProperties || (prototypeProperties = {});
  constructorProperties || (constructorProperties = {});
  // End unpack args
  var parent = this;
  // constructor may be defined in prototypeProperties:
  var child = _.has(prototypeProperties, 'constructor') ?
    prototypeProperties.constructor :
    (function ExtendedConstructor () { parent.apply(this, arguments); });
  util.inherits(child, parent); // Extend prototype from parent to child
  // Add constructor properties from parent and params. Set `extend`
  // reference as well in case it is not defined on parent.
  _.extend(child, parent, constructorProperties, { extend: extend });
  // Add prototype properties from params. Set `constructor` reference too
  // because not all javascript engines do this automatically.
  _.extend(child.prototype, prototypeProperties, { constructor: child });
  return child;
};

/** @classdesc Base error constructor.
  * All errors generated by {@link Charon.Error} should test positive for
  * `instanceof Error`. This constructor is provided here primarily for
  * type-checking purposes. In practice, errors should be created using an
  * error constructor derived from either {@link Charon.ServiceError} or
  * {@link Charon.ConsumerError}.
  * @constructor
  * @extends Global.Error
  * @abstract
  */
Charon.Error = extend.call(Error,
  /** @lends Charon.Error.prototype */
  {
    /** @param {String} [message=''] - Brief description of the problem.
      * @param {Object} [data={}] - Additional information about the error. Note,
      * If `data` is not an object, it will be converted to an object with
      * the original `data` argument set at the `value` property.
      */
    constructor: function Error (message, data) {
      // Unpack args
      // unshift arguments if data is first arg
      if (_.isObject(message)) {
        data = message;
        message = undefined;
      }
      // apply defaults
      data || (data = {});
      message || (message = '');
      // data must be an object - convert to object now if not
      if (! _.isObject(data)) {
        data = { value: data };
      }
      // message must be a string
      message = message.toString();
      // End unpack args
      /** Additional data about the error.
        * @type {Object} */
      this.data = data;
      /** Brief description of the problem.
        * @type {String}
        */
      this.message = message;
    },
    /** Error name prototype property provided to identify instances of
      * {@link Charon.Error}. This property should be changed for
      * constructors which extend {@link Charon.Error}.
      * @readonly
      * @default
      * @type String
      */
    name: "Error"
  },
  /** @lends Charon.Error */
  {
    /** Static property to distinguish this constructor (and extensions of
      * this constructor) from other things.
      * @constant
      * @default
      * @type Boolean */
    isCharonErrorConstructor: true
  });

/** All error constructors are referenced here.
  * @see {@link Charon.Error} */
Charon.errors = { Error: Charon.Error };

// A helper utility to streamline defining new error types within Charon.
// Automatically assigns created error within {@link Charon.errors}.
var extendError = function defineErrorExtension (parent, name) {
  return Charon.errors[name] = parent.extend({ name: name });
};

/** @classdesc Indicates a problem in usage which may be resolved by the
  * consumer, e.g., failure to authenticate, invalid data, insufficient
  * permissions, unauthorized user, etc. Roughly maps to a HTTP 4xx response
  * code. All {@link Charon.Error} extensions should extend from either this
  * constructor, or {@link Charon.ServiceError}.
  * @constructor
  * @extends Charon.Error */
Charon.ConsumerError = extendError(Charon.Error, 'ConsumerError');

/** @classdesc Indicates a problem somewhere in the service or one of its
  * dependencies, e.g., unhandled exception, service unavailable, gateway
  * timeout, etc. Roughly maps to a HTTP 5xx response code.
  * Note, in this context, the "service" includes the client through which
  * the service is invoked. All {@link Charon.Error} extensions should extend
  * from either this * constructor, or {@link Charon.ConsumerError}.
  * @constructor
  * @extends Charon.Error */
Charon.ServiceError = extendError(Charon.Error, 'ServiceError');

/** @classdesc Indicates the service understands the request but refuses to
  * fulfill it. Roughly maps to a HTTP 403 response code.
  * @constructor Charon.RequestForbiddenError
  * @extends Charon.ConsumerError */
Charon.RequestForbiddenError = extendError(Charon.ConsumerError,
  'RequestForbiddenError');

/** @classdesc Indicates the service cannot find the requested resource.
  * Roughly maps to a HTTP 404 response code.
  * @constructor Charon.ResourceNotFoundError
  * @extends Charon.ConsumerError */
Charon.ResourceNotFoundError = extendError(Charon.ConsumerError,
  'ResourceNotFoundError');

/** @classdesc Indicates the service cannot fulfill the request due to a
  * conflict at the resource address. Roughly maps to a HTTP 409 response code.
  * @constructor Charon.ResourceConflictError
  * @extends Charon.ConsumerError */
Charon.ResourceConflictError = extendError(Charon.ConsumerError,
  'ResourceConflictError');

/** @classdesc Indicates a programming error in client usage.
  * @constructor Charon.IntegrationError
  * @extends Charon.ConsumerError */
Charon.IntegrationError = extendError(Charon.ConsumerError,
  'IntegrationError');

/** @classdesc Indicates an unexpected programming error (e.g.,
  * unhandled exception). Typically due to an error in the client, the Charon
  * library, or a dependency.
  * @constructor Charon.RuntimeError
  * @extends Charon.ServiceError */
Charon.RuntimeError = extendError(Charon.ServiceError, 'RuntimeError');

/** @classdesc Indicates failure to parse service response. Generally indicates
  * data contains bad syntax or information was not structured as expected.
  * @constructor Charon.ParseError
  * @extends Charon.ServiceError */
Charon.ParseError = extendError(Charon.ServiceError, 'ParseError');

/** @classdesc Indicates service did not complete within specified timeout
  * period.
  * @constructor Charon.TimeoutError
  * @extends Charon.ServiceError */
Charon.TimeoutError = extendError(Charon.ServiceError, 'TimeoutError');

/** @callback Charon.errFirstCallback
  * @desc This callback interface follows a subset of the Node.js callback
  * convention. Note that while, by convention, callbacks may be passed a
  * variable number of arguments between error and callback, this particular
  * interface requires that one and only one argument be included between
  * the first position (err) and the third position (callback). This
  * restriction is intended to support composition.
  * @param {Error} err - Error instance or null
  * @param {*} [data] - Payload data or null */

/** @callback Charon.CascadingCallback
  * @desc This callback interface follows a subset of the Node.js callback
  * convention. Note that while, by convention, callbacks may be passed a
  * variable number of arguments between error and callback, this particular
  * interface requires that one and only one argument be included between
  * the first position (err) and the third position (callback). This
  * restriction is intended to support composition.
  * Also note, this interface may be considered an extension of the {@link
  * Charon.errFirstCallback} interface.
  * @param {Error} err - Error instance or null
  * @param {*} data - Payload data or null
  * @param {Charon.errFirstCallback} callback - Next callback to invoke */

/** @classdesc Creates an asynchronous middleware function which implements
  * the {@link Charon.CascadingCallback} interface. The created middleware is
  * composed of component functions which each implement the
  * {@link Charon.CascadingCallback} interface and are called in series when
  * the middleware is invoked. The created instance also contains properties
  * allowing client authors to access and modify the underlying array of
  * component functions.
  * @param {...Charon.CascadingCallback|Charon.CascadingCallback[]}
  * components - The asynchronous function callbacks which should be chained
  * together in series to create the middleware.
  * @constructor */
Charon.Middleware = function Middleware (components) {
  // Unpack args
  components || (components = []);
  if (! _.isArray(components)) {
    components = _.toArray(arguments);
  }
  // End unpack args
  // create and return the callable instance
  return _.extend(
    function Middleware (err, data, callback) {
      // Unpack args
      callback || (callback = function () {});
      // End unpack args
      var componentIndex = 0;
      var callNextComponent = function callNextComponent (err, data) {
        var component = components[componentIndex];
        componentIndex++;
        if (component) {
          component.call(this, err, data, callNextComponent);
        }
        else {
          callback.call(this, err, data);
        }
      };
      callNextComponent.call(this, err, data);
      return this;
    },
    /** @lends Charon.Middleware#prototype */
    {
      /** Number of Middleware function components (set of function components
        * is non-mutable.)
        * @constant 
        * @type Number */
      length: components.length,

      /** Calls `slice` on the internal array of Middleware function
        * components. Defined here so that Middleware instances may be copied
        * and extended.
        * @returns [Charon.CascadingCallback] */
      slice: function slice () {
        return Array.prototype.slice.apply(components, arguments);
      },

      /** Constant property to distinguish Middleware instances from other
        * things.
        * @constant
        * @default
        * @type Boolean */
      isMiddleware: true
    }
  );

};

/** All predefined implementations suitable for {@link
  * Charon.Client#urlTemplateProcessor} are referenced here. */
Charon.urlTemplateProcessors = {

  /** Implements simple value substitution with leading-colon syntax /
    * substitution rules, as used by the Express and Restify projects.
    * @see {@link http://expressjs.com/api.html#app.VERB}
    * @see {@link http://mcavage.me/node-restify/#Routing}
    * @param {String} urlTemplate - A URL template string
    * @param {Object} templateVariables} - A set of properties used for
    * expanding the URL template.
    * @returns {String} Expanded URL
    * @example
    * expressProcessor('http://foo.com/:id', { id: 'bar' })
    * // 'http://foo.com/bar' */
  expressProcessor: function expressProcessor (urlTemplate, templateVariables) {
    templateVariables || (templateVariables = {});
    var expansion = urlTemplate;
    var urlTemplateRegex = /:([a-zA-Z_$][\w_$]*)/g;
    var matches;
    var key, value;
    while ((matches = urlTemplateRegex.exec(urlTemplate)) !== null) {
      key = matches[1];
      value = templateVariables[key] || '';
      expansion = expansion.replace(matches[0], value);
    }
    return expansion;
  }

  // TODO implement full RFC6570 implementation
  //  (See http://tools.ietf.org/html/rfc6570#section-3.2.1)
};


/** @classdesc Creates an Object representation of a linked service.
  * @constructor
  * @property {String} href - An absolute URL.
  * @property {String} [method] - HTTP method accepted at the indicated href
  * @property {String} [rel] - Link relation type. This value must be a URL,
  * unless it is one of the registered relation types. See {@link
  * http://www.iana.org/assignments/link-relations}.
  * @property {String} [mediaType] - The media type (or media range) expected
  * to be returned when requesting the href. See {@link
  * http://tools.ietf.org/html/rfc2046} and {@link
  *  http://tools.ietf.org/html/rfc2616#section-14.1}.
  * @property {String} [title] - Human-readable title of the link
  * @property {String} [*] - Any other properties not defined here may be set
  * as extensions by the client author. */
Charon.Link = extend.call(Function,
  /** @lends Charon.Link.prototype */
  {
    /** Given an href string, base url, and a set of template variables,
      * expand the href (assuming it is a URL template) and resolve against
      * the given base URL.
      * @param {Object} [attributes={}] - Link attributes
      * @param {String} [attributes.href=''] - A hyper-reference (may be
      * relative path or absolute URL, and may be a URL template).
      * @param {String} [attributes.*] - Any link properties may be specified
      * within attributes. See {@link Charon.Link}.
      * @param {String} [baseUrl=DEFAULT_BASE_URL] - An absolute URL used
      * for resolving relative hrefs.
      * @param {Object} [templateVariables={}] - A set of properties used to
      * expand the URL template.
      */
    constructor: function Link (attributes, baseUrl, templateVariables) {
      // Unpack args
      attributes = _.clone(attributes || {});
      attributes.href || (attributes.href = '');
      baseUrl || (baseUrl = DEFAULT_BASE_URL);
      templateVariables || (templateVariables = {});
      // End unpack args
      attributes.href = this.resolveUrl(
        this.processUrlTemplate(attributes.href, templateVariables),
        baseUrl);
      _.extend(this, attributes);
    },

    /** Platform-dependent function responsible for resolving a hyper-reference
      * string, which may be potentially relative or absolute, against the
      * given base url.
      * May be overridden by the client author for compatibility with a
      * different HTTP library (uses Node.js's `url` lib by default), but
      * otherwise should not need any service-specific changes.
      * @param {String} baseUrl - An absolute URL used for resolving
      * relative paths.
      * @param {String} href - A hyper-reference (may be relative or
      * absolute URL).
      * @returns {String} Resolved, absolute URL. */
    resolveUrl: function (href, baseUrl) {
      return url.resolve(baseUrl, href);
    },

    /** Processes a URL template and returns the expansion string, with
      * `urlTemplate` placeholder tokens replaced by data from 
      * `templateVariables`.
      * May be overridden by the client author to implement alternative url
      * template processor or to bypass url templating altogether.
      * Predefined alternative processors are available at
      * {@link Charon.urlTemplateProcessors}.
      * @default Charon.urlTemplateProcessors.expressProcessor
      * @param {String} urlTemplate - A URL template string
      * @param {Object} templateVariables} - A set of properties used for
      * expanding the URL template.
      * @returns {String} Expanded URL */
    processUrlTemplate: Charon.urlTemplateProcessors.expressProcessor

  });


/** @classdesc Creates an instance representng a resource from a REST service.
  * @constructor
  * @example
  * var resource = new Charon.Resource({
  *   data: { id: 5, name: 'Sam' },
  *   links: [ { rel: 'self', href: 'http://example.com/users/5' } ]
  * });
  * resource.id // 5
  * resource.getData() // { id: 5, name: 'Sam' }
  * resource.getLinks({rel: 'self'})[0].href // 'http://example.com/users/5'
  */
Charon.Resource = extend.call(Function,
  /** @lends Charon.Resource.prototype */
  {
    /** @param {Object} resourceParams - An object containing the components that
      * constitute a Resource instance.
      * @param {Object} resourceParams.data - The parsed resource data
      * @param {Object} resourceParams.meta - Additional meta data related to
      * the resource but not part of the resource itself (e.g., last-modified).
      * @param {Charon.Link[]} resourceParams.links - Links to other related
      * resources.
      * @param {Charon.Response} [resourceParams.response] - Javascript Object
      * representation of HTTP response. For use by client authors. */
    constructor: function Resource (resourceParams) {
      // Unpack args, apply defaults
      var data = _.clone(resourceParams.data || {});
      var links = (resourceParams.links || []).slice();
      var meta = _.clone(resourceParams.meta || {});
      // End unpack args
      // Create an extension of the Resource constructor with read-only getter
      // functions on the prototype, so these properties do not register
      // positive when checked with `resourceInstance.hasOwnProperty`.
      var ResourceCtor = extend.call(Charon.Resource, {
        /** Should not be used directly by integrators. May be used by client
          * authors to write middleware that populate and/or modify the links.
          * @instance Charon.Resource */
        _getLinks: function _getLinks () { return links; },

        /** Should not be used directly by integrators. May be used by client
          * authors to write middleware that populate and/or modify meta data.
          * @instance Charon.Resource */
        _getMeta: function _getMeta () { return meta; },

        /** Should not be used directly by integrators. May be used by client
          * authors to write middleware that populate and/or modify resource
          * links and/or meta data from response data.
          * @instance Charon.Resource */
        _getResponse: function _getResponse () {
          return resourceParams.response;
        },

        // Override constructor to avoid recursion
        constructor: function Resource () {}
      });
      var resource = new ResourceCtor();
      // Apply all data as properties of the resource
      _.extend(resource, data);
      return resource;
    },

    /** @returns {Charon.Link[]} Returns links for the resource, with optional
      * filters applied.
      * @param {Object} [options={}] - Filter to apply to set of links
      * @TODO document options
      * @readonly */
    getLinks: function (options) {
      // Unpack args
      options || (options = {});
      // End unpack args
      var filteredLinks = this._getLinks().slice();
      if (_.isObject(options.where)) {
        filteredLinks = _.where(filteredLinks, options.where);
      }
      if (_.isFunction(options.filter)) {
        filteredLinks = _.filter(filteredLinks, options.filter);
      }
      return filteredLinks;
    },

    /** @returns {Object} Returns the full meta data for the resource.
      * @readonly */
    getMeta: function () { return _.clone(this._getMeta()); },

    /** @returns {String} The base URL for the resource, which may be used
      * to both refer to the resource and to resolve references relative to
      * the resource.
      * @see {@Link http://tools.ietf.org/html/rfc3986#section-5.1} */
    getBaseUrl: function () {
      return (this.getLinks({ where: { rel: 'self' } })[0] ||
        this._getResponse().request.url);
    },

    /** Creates a link and adds it to the set of Links defined for this
      * resource, using the resource base URL and data to resolve the `href`
      * and expand any template placeholders.
      * @param {Object} attributes - Link attributes, same as those accepted by
      * {@link Charon.Link#constructor}.
      * @returns {Charon.Link} Returns the created link */
    _addLink: function (attributes) {
      var link = new Charon.Link(attributes, this.getBaseUrl(), this);
      this._getLinks().push(link);
      return link;
    }
  }
);


/** @callback Charon.transmitCallback
  * @param {Error} err - Error instance or null
  * @param {response} response - response data */

/** @typedef {Object} Charon.Response
  * @desc A normalized Object representation of an HTTP response.
  * @property {Number} statusCode - The HTTP status code
  * @property {String|Object} body - The response entity
  * @property {Charon.Header[]} headers - The response headers
  * @property {Charon.Request} request - Request data container
  */

/** @typedef {Object} Charon.Request
  * @desc A normalized Object representation of an HTTP request.
  * @property {String} url - The URL target for the request.
  * @property {String} method - The HTTP method of the request.
  * @property {String|Object} body - The request entity-body
  * @property {Charon.Header[]} headers - The request headers
  * @property {Number} timeout - The maximum time to wait for a response,
  * in seconds */

//                   TODO FIXME need a proper model for headers.
//                   currently headers are in whatever format defined by
//                   the `request` lib (arrays for cookies,
//                   comma-delimited string for some special headers,
//                   and default duplicate headers are ignored). This would
//                   be a backwards-incompatible change and needs
//                   significant test coverage and documentation.


/** Charon network communication integration with the
  * [Node.js Request lib]{@link https://github.com/mikeal/request}.
  * Responsible for sending an HTTP request and invoking the callback
  * with the response data.
  * @param {Charon.Request} request - Request data
  * @param {errFirstCallback} callback - Invoked with {@link Charon.Response}
  * object as data payload. */
Charon.transmitWithRequestLib = function transmitWithRequestLib (
  request, callback
) {
  requestLib({
    json: request.body || true,
    url: request.url,
    method: request.method,
    headers: request.headers,
    timeout: request.timeout * 1000  // Seconds to milliseconds
  }, _.bind(function onRequestCallback (err, response, body) {
    var callbackErr = null;
    var response;
    if (err) {
      if (err.code && err.code.indexOf("TIMEDOUT") !== -1) {
        callbackErr = new Charon.TimeoutError(
          "Timeout after " + request.timeout + "s",
          { err: err, request: request });
      }
      else {
        callbackErr = new Charon.RuntimeError('HTTP client error',
          { err: err, request: request });
      }
    }
    else {
      // TODO FIXME need to include followed reirects for purposes of
      // resolving relative URLs
      response = {
        body: body,
        statusCode: response.statusCode,
          // TODO FIXME should parse `rawHeaders` directly because the
          // Node HTTP lib can throw away some headers.
          // See https://github.com/joyent/node/blob/085dd30e93da67362f044ad1b3b6b2d997064692/lib/_http_incoming.js#L186
        headers: response.headers,
        request: request
      };
      // The request lib silently fails on JSON parse errors.
      // We should make parse failures explicit in order to "communicate
      // bad news as soon as possible and in as much detail as possible".
      // Note, This error-checking code will give a false positive for
      // JSON-serialized string response bodies, because those strings will
      // have already been parsed by the Request lib. However, String
      // response bodies are not a common use-case for JSON entities.
      if (_.isString(body)) {
        var responseType = response.headers['content-type'];
        if ((responseType || '').indexOf('application/json') === 0) {
          // resource indicates JSON but body is not parsed
          try {
            response.body = JSON.parse(response.body);
          }
          catch (e) {
            callbackErr = new Charon.ParseError(
              'Failed to parse resource identified as JSON',
              {
                err: e,
                response: response
              });
          }
        }
      }
    }
    callback.call(this, callbackErr, callbackErr ? null : response);
  }, this));
};

/** All predefined implementations suitable for {@link
  * Charon.Client#requestMiddleware} are referenced here. */
Charon.requestMiddlewares = {};

/** All predefined implementations suitable for {@link
  * Charon.Client#responseMiddleware} are referenced here. */
Charon.responseMiddlewares = {

  /** Attempts to detect errors in the `response` and create / pass 
    * error instances to the `next` callback as necessary.
    * @param {Charon.Error} err
    * @param {Charon.Response} response
    * @param {Charon.errFirstCallback} next */
  detectErrors: function detectErrors (err, response, next) {
    var callbackErr = null;
    if (err) {
      callbackErr = err;
    }
    else {
      var status = response.statusCode;
      if (status == 403) {
        callbackErr = new Charon.RequestForbiddenError(response);
      }
      else if (status == 404) {
        callbackErr = new Charon.ResourceNotFoundError(response);
      }
      else if (status == 409) {
        callbackErr = new Charon.ResourceConflictError(response);
      }
      else if (status >= 400 && status <= 499) {
        // 4xx error
        callbackErr = new Charon.ConsumerError(response);
      }
      else if (status >= 500 && status <= 599) {
        // 5xx error
        callbackErr = new Charon.ServiceError(response);
      }
      else if (! (status >= 200 && status <= 299)) {
        // not sure what this is, but it's not successful
        callbackErr = new Charon.RuntimeError('Unrecognized HTTP status code', response);
      }
    }
    next.call(this, callbackErr, callbackErr ? null : response);
  }

};


/** All predefined implementations suitable for {@link
  * Charon.Client#resourceMiddleware} are referenced here. */
Charon.resourceMiddlewares = {

  /** Sets `resource` data properties with response data, if not
    * already set.
    * @param {Charon.Error} err
    * @param {Charon.Resource} resource
    * @param {Charon.errFirstCallback} next */
  setDefaultResourceFromBody: function setDefaultResourceFromBody (
    err, resource, next
  ) {
    if (! err && _.isObject(resource._getResponse().body)) {
      _.extend(resource, resource._getResponse().body);
    }
    next.call(this, err, err ? null : resource);
  },

  /** Sets the "rel=self" link on `resource` if not already set, based on the
    * request URL.
    * @param {Charon.Error} err
    * @param {Charon.Resource} resource
    * @param {Charon.errFirstCallback} next */
  setDefaultSelfLinkFromRequest: function setDefaultSelfLinkFromRequest (
    err, resource, next
  ) {
    if (! err && ! resource.getLinks({ where: { rel: 'self' } }).length) {
      resource._getLinks().push(new Charon.Link({
        href: resource._getResponse().request.url,
        rel: 'self'
      }));
    }
    next.call(this, err, err ? null : resource);
  }
};


/** @classdesc Creates an instance which contains configuration options and
  * default behaviors used to consume RESTful services.
  * @constructor
  * @mixes Charon
  */
Charon.Client = extend.call(Function, _.extend({},
  Charon,
  /** @lends Charon.Client.prototype */
  {
    /** @param {Object} [overrides] - Properties to apply to the created
      * Client instance. */
    constructor: function Client (overrides) {
      _.extend(this, overrides);
      var client = this;
    },

    /** Creates a Client instance with both inherited and overridden behavior.
      * Extensions inherit behavior from the parent instance, but extension
      * behavior may be modified from parent defaults by specifying overrides.
      * properties of the resource manager.
      * @param {Object} [overrides] - Properties to apply to the
      * new client instance.
      * @returns {Charon.Client}
      * @example
      * var MyClient = new Charon.Client({
      *   initialize: function (options) {
      *     this.isSpecial = function () { return true; };
      *   }
      * });
      * var MyClientSubdivision = MyClient.createExtension({
      *   extraSpecial: true
      * }); */
    createExtension: function (overrides) {
      overrides || (overrides = {});
      var parent = this;
      var child = new Charon.Client();
      _.extend(child, overrides);
      // set child to proxy-call parent functions which are not overridden
      _.each(_.functions(parent), function (key) {
        if (
          // Do not proxy-call constructors under the Charon namespace
          ! Charon[key] &&
          // Do not proxy-call functions which are overridden on child
          ! _.has(child, key)
        ) {
          child[key] = function proxiedFunction () {
            return parent[key].apply(this, arguments);
          };
        }
      }, this);
      return child;
    },

    /** Defines multiple "client services" (i.e., specialized sub-clients) and
      * assigns convenience functions to properties on `this` instance.
      * This is mainly a convenience method for navigating APIs which do not
      * provide links in their responses - the more canonical use case is for
      * integrators to follow links provided by the service, rather than
      * invoking hard-coded services defined by the client author.
      * @param {Object} serviceDeclaration - Map of instance property
      * names to client extension parameters. `This` instance will have keys
      * froom the `serviceDeclaration` object set to newly created functions
      * which proxy to `submit` functions of specialized {@link Charon.Client}
      * extensions created and stored in closure. */
    declareServices: function (serviceDeclaration) {
      _.each(serviceDeclaration, function (clientParams, name) {
        var serviceClient = this.createExtension(clientParams);
        this[name] = serviceClient.submit.bind(serviceClient);
      }, this);
    },

    /** Applies configuration data and function overrides to the client.
      * Intended to be run just once, at time of app bootstrap /
      * initialization. Should not be overridden by the client author without
      * care.
      * @param {Object} [params] - The properties of the `params` argument will
      * be used to augment the {@link Charon.Client} instance. Param function
      * properties will be applied directly to the instance as properties,
      * and all extensions of the client will inherit the new function value.
      * Param non-function properties will be stored in an internal closure
      * variable and made accessible via {@link Charon.Client#getConfig}.
      * @param {Charon.errFirstCallback} [callback]
      * @returns {Charon.Client} `this`
      * @see {Charon.Client#isInitialized} */
    initialize:  function initialize (params, callback) {
      // Unpack args
      params || (params = {});
      callback || (callback = function () {});
      // End unpack args
      var overrides = _.pick(params, _.functions(params));
      var config = _.omit(params, overrides);
      _.extend(this, overrides,
        { getConfig: function getConfig () { return config; },
          isInitialized: function isInitialized () { return true; }
        });
      callback();
      return this;
    },

    /** This function tracks whether the client instance has been initialized
      * or not. It should return a static value and should be updated only when
      * the app has actually been initialized. A client author may override
      * this function if he/she wishes to disable the requirement that clients
      * be initialized before use.
      * @see {Charon.Client#initialize}
      * @returns {Boolean} */
    isInitialized: function isInitialized () {
      return false;
    },

    /** @see {Charon.Client#initialize}
      * @returns {Object} Configuration data set at initialization. */
    getConfig: function getConfig () {
      return {};
    },

    /** @typedef {Object} Charon.SubmissionSpec
      * @desc The parameters provided by the integrator when calling {@link
      * Charon.Client#submit}.
      * @property {Charon.Link} [link={}] - A link to the service to be
      * consumed.
      * @property {Object|String} [data] - The service payload, e.g., search
      * parameters or a resource representation. Objects are serialized to
      * JSON before being transmitted across the wire.
      * @property {*} [*] - Other properties may be set on the submission
      * parameter object at the client author's descretion.
      */

    /** Submits a request to the indicated service and invokes the callback
      * with the resource from the response. Intended to be the general
      * entry-point for integrators.
      * @param {Charon.SubmissionSpec} submissionSpec - Submission parameters
      * @param {Charon.errFirstCallback} callback - Service callback */
    submit: function (submissionSpec, callback) {
      // Unpack args
      // submissionSpec may be omitted, shifting args
      if (_.isFunction(submissionSpec)) {
        callback = submissionSpec;
        submissionSpec = undefined;
      }
      // apply defaults
      submissionSpec || (submissionSpec = {});
      submissionSpec.link || (submissionSpec.link = {});
      callback || (callback = function () {});
      // End unpack args
      if (! this.isInitialized()) {
        callback(new Charon.RuntimeError("Client is not initialized"));
      }
      else {
        this.execute(submissionSpec, callback);
      }
    },

    /** @private */
    execute: function execute (submissionSpec, callback) {
      var request = {
        url: this.getUrl(submissionSpec),
        method: this.getMethod(submissionSpec),
        body: this.getBody(submissionSpec),
        headers: this.getHeaders(submissionSpec),
        timeout: this.getTimeout(submissionSpec)
      };
      async.waterfall([
        _.bind(this.requestMiddleware, this, null, request),
        _.bind(this.transmit, this), 
        _.bind(this.handleResponse, this)
      ], callback);
    },

    /** @private */
    handleResponse: function (response, callback) {
      async.waterfall([
        _.bind(this.responseMiddleware, this, null, response),
        _.bind(function makeResourceSpec (response, next) {
          next(null, new Charon.Resource({
            data: {},
            meta: {},
            links: [],
            response: response
          }));
        }, this),
        _.bind(this.resourceMiddleware, this, null),
      ], callback);
    },

    /** Platform-dependent function responsible for sending the request
      * message as specified to the URL indicated and capturing the response
      * data as a {@link Charon.Response} formatted object.
      * May be overridden by the client author for compatibility with a
      * different network communication library, but
      * otherwise should not need any service-specific changes.
      * @param {Charon.Request} request - Request specification
      * @param {Charon.errFirstCallback} callback */ 
    transmit: Charon.transmitWithRequestLib,

    /** Produces the default URL against which links are resolved, aka the
      * "service root". This will be a constant value. Most integrations will
      * want to override this function during initialization to target a
      * specific environment. The client author may also override this function
      * with a sane default, e.g., the production server base URL.
      * @returns {String} URL */
    getBaseUrl: function getBaseUrl () {
      return DEFAULT_BASE_URL;
    },

    /** Produces the URL used for the service request. May be overridden by the
      * client author to add query string parameters, etc. Also see {@link
      * Charon.Client#processUrlTemplate}.
      * @param {Charon.SubmissionSpec} submissionSpec - Submission parameters
      * @returns {String} Fully-qualified request URL.
      * @default The service link `href` property, or "". */
    getUrl: function getUrl (submissionSpec) {
      return submissionSpec.link.href || '';
    },

    /** Produces the HTTP method used for the service request. May be
      * overridden by the client author as desired.
      * @param {Charon.SubmissionSpec} submissionSpec - Submission parameters
      * @returns {String} HTTP Request method (e.g., "GET").
      * @default The service link `method` property, or "GET". */
    getMethod: function getMethod (submissionSpec) {
      return submissionSpec.link.method || "GET";
    },

    /** Produces the HTTP headers to be used for the service request. may be
      * overridden by the client author as desired, for example, to add
      * authorization or content type information.
      * @param {Charon.SubmissionSpec} submissionSpec - Submission parameters
      * @returns {Charon.Header[]} Request headers.
      * @default Empty array. */
    getHeaders: function getHeaders (submissionSpec) {
      return [];
    },

    /** @param {Charon.SubmissionSpec} submissionSpec - Submission parameters
      * @returns {Object|String} Request body. If object, the return value
      * will be serialized to JSON before the request is transmitted.
      * @default The `data` property of the service submission parameters. */
    getBody: function getBody (submissionSpec) {
      return submissionSpec.data;
    },

    /** Produces the maximum time to wait for a response from the service,
      * after which an error will be returned to the callback.
      * @param {Charon.SubmissionSpec} submissionSpec - Submission parameters
      * @returns {Number} Timeout period in seconds.
      * @default undefined (timeout feature disabled) */
    getTimeout: function getTimeout (submissionSpec) {
      return undefined;
    },

    /** Middleware called before the request is transmitted.
      * This middleware may be used for altering request parameters object,
      * logging, etc.
      *
      * Implements {@link Charon.Middleware} interface.
      * @see {@link Charon.requestMiddlewares}
      * @function
      * @param {Error} err
      * @param {Charon.Request} request
      * @param {Charon.errFirstCallback} next */
    requestMiddleware: new Charon.Middleware(),

    /** Middleware called after the response is received and before the
      * resource is extracted from the response. May be used for transforming
      * the response object, handling HTTP error responses, logging, etc.
      * Note, this middleware may decorate `err` with additional information,
      * if, for example, the response contains helpful data or links related
      * to an error condition. Parsed error data should be set as an object at
      * `err.data.data`, and links may be set at `err.data.links`.
      *
      * Implements {@link Charon.Middleware} interface.
      * @see {@link Charon.responseMiddlewares}
      * @function
      * @param {Error} err
      * @param {Charon.Response} response
      * @param {Charon.errFirstCallback} next */
    responseMiddleware: Charon.Middleware(
      Charon.responseMiddlewares.detectErrors
    ),

    /** Middleware called just before the {@link Charon.Resource} instance is
      * created. This middleware may be used to transform the resource data
      * before the Resource instance is created, e.g., to add additional links
      * to a resource with well-known stable relationships.
      *
      * Implements {@link Charon.Middleware} interface.
      * @see {@link Charon.resourceMiddlewares}
      * @function
      * @param {Error} err
      * @param {Charon.Resource} resource
      * @param {Charon.errFirstCallback} next */
    resourceMiddleware: new Charon.Middleware(
      Charon.resourceMiddlewares.setDefaultSelfLinkFromRequest,
      Charon.resourceMiddlewares.setDefaultResourceFromBody
    )
  })
);

// TODO URL template RFC6570 (see http://medialize.github.io/URI.js/)
// TODO document getLinks filter methods
// TODO set redirect URL on response.request.url
// TODO parse headers from raw string
// TODO new header data model
// TODO implement filter interface for getting response headers
