var util = require('util');
var _ = require('underscore');
var request = require('request');

var Charon = module.exports = {};

// Creates a child of ``this`` constructor, optionally with additional
// prototype and constructor properties.
// Preserves inheritance chain for use of ``instanceof``.
// Child constructors contain a reference to ``extend``, and prototypes
// include a valid ``constructor`` reference.
// Example:
//   var MyErrorType = extend.call(Error, { name: 'MyErrorType' });
var extend = function extend (prototypeProperties, constructorProperties) {
  // unpack args: default empty objects
  prototypeProperties || (prototypeProperties = {});
  constructorProperties || (constructorProperties = {});
  // end unpack args
  var parent = this;
  // constructor may be defined in prototypeProperties:
  var child = _.has(prototypeProperties, 'constructor') ?
    prototypeProperties.constructor :
    function () { parent.apply(this, arguments); };
  util.inherits(child, parent); // extend prototype from parent to child
  // Add constructor properties from parent and params. Set ``extend``
  // reference as well in case it is not defined on parent.
  _.extend(child, parent, constructorProperties, { extend: extend });
  // Add prototype properties from params. Set ``constructor`` reference too
  // because not all clients do this automatically.
  _.extend(child.prototype, prototypeProperties, { constructor: child });
  return child;
};

var errors = {};

// Abstract base error constructor. All errors generated by Charon
// should test positive as ``instanceof`` this constructor, but in practice
// all errors are actually created using a more specific error defined below.
// ``message``: optional string describing the problem. Intended for debugging.
// ``data``: optional object or array with more information about the error
errors.Error = extend.call(Error, {
    constructor: function CharonError (message, data) {
      // unpack args: message and data are both optional
      // if first arg is an object or array, assume ``message`` was omitted and 
      // first arg is actually ``data``
      if (_.isObject(message) || _.isArray(message)) {
        data = message;
        message = undefined;
      }
      // end unpack args
      if (data) {
        if (_.isObject(data) || _.isArray(data)) {
          this.data = data;
        }
        else {
          this.data = {
            CharonError: "invalid error data type: " + typeof data,
            originalData: data
          };
        }
      }
      this.message = message ? message.toString() : '';
    },
    name: "Charon.Error"
  },
  {
    isCharonErrorConstructor: true
  });

// Two basic error types are used to describe whether the error is due to
// usage (e.g., 4xx, invalid data, unauthorized user) or due to a fault within
// the service or one of its components (e.g., 5xx, unhandled exception, service
// unavailable).
errors.ConsumerError = errors.Error.extend({ name: 'Charon.ConsumerError' });
errors.ServiceError = errors.Error.extend({ name: 'Charon.ServiceError' });

// Error subtypes. These errors are derived from the two basic error types
// defined above. They are provided here in order to help applications present
// more accurate and helpful information to end users, but their usage is not
// required within an integration.

// the service understands the request but refuses to fulfill it
errors.RequestForbiddenError = errors.ConsumerError.extend({ name: 'Charon.RequestForbiddenError' });
// the service cannot find the requested resource
errors.ResourceNotFoundError = errors.ConsumerError.extend({ name: 'Charon.ResourceNotFoundError' });
// the service cannot fulfill the request at this time due to a resource conflict
errors.ResourceConflictError = errors.ConsumerError.extend({ name: 'Charon.ResourceConflictError' });
// Unexpected programming error (e.g., unhandled exception)
errors.RuntimeError = errors.ServiceError.extend({ name: 'Charon.RuntimeError' });

// supply a reference to all errors in the Charon library
_.extend(Charon, errors);


// A client contains configuration options and one or more resource services.
// This constructor is an internal implementation detail; integrators are
// expected to define clients by creating instances using the ``ClientFactory``
// method, below, and modifying the instance to add necessary service refrences
// and/or custom initialization logic.
// Note, Clients must be initialized after ResourceManager references have been
// assigned. Otherwise, the ResourceManager will not have a reference to the
// client and will not be able to instantiate new instances.
Charon.Client = extend.call(Function, _.extend({},
  errors, // supply a reference to all errors in Client instances
  {
    constructor: function CharonClient () {
      // create a default blank log function
      this.log = function () {};
    },

    // ``options``: Object, set automatically on instance properties
    //    ``log``: An optional logging function which should accept these args:
    //                ``level`` (String), eg "error", "debug", etc,
    //                ``message`` (String), human-readable log message
    //                ``obj`` (Object), additional data
    // may be overridden by the integrator
    initialize:  function (options) {
      _.extend(this, options);
      this.initializeResourceManagers();
    },

    initializeResourceManagers: function () {
      // every constructor reference on the Client instance should receive
      // a reference to the Client instance.
      for (field in this) {
        var member = this[field];
        if (member.isCharonResourceManagerConstructor) {
          member.client = this;
        }
      }
    }
  }), {
    isCharonClientConstructor: true
  });

// Defines a Client type and returns an instance of it.
// ``properties``: Object, optional prototype properties to add to the client.
// Example:
//    var MyClient = Charon.ClientFactory({
//      initialize: function (options) {
//        this.special = true;
//        Charon.Client.apply(this, arguments);
//      }
//    });
Charon.ClientFactory = function (properties) {
  var ClientCtor = Charon.Client.extend(properties);
  return new ClientCtor();
};

// A helper utility to allow integrators to define a service operation instance
// method for a resource service.
// ``options``: Object, operation definition parameters
//    ``name``    : String, name of the operation (used for logging)
//    ``wrappers``: Array, one or more callback wrapper functions.
//                  Each wrapper function should accept ``wrapped``(Function),
//                  ``err` (Error), ``resource`` (Object) arguments, and should
//                  invoke the ``wrapped`` function with error and resource
//                  arguments.
//    Note, all other options are passed through to ``buildRequestSpec``.
Charon.defineManagerOperation = function (options) {
  return function (callback) {
    callback || (callback = function () {});
    if (options.wrappers) {
      _.each(options.wrappers, function (wrapper) {
        callback = _.wrap(callback, _.bind(wrapper, this));
      });
    }
    // this function is responsible for invoking the callback with both
    // resource and a reference to the instance
    var onResponseHandlingComplete = _.bind(function (err, response) {
      return callback(err, response, this);
    }, this);

    var requestSpec = this.buildRequestSpec(options);
    var responseHandler = this.responseHandlerFactory(onResponseHandlingComplete);
    this.submitRequest(requestSpec, responseHandler);
  };
};

// A helper utility to allow integrators to define "static" versions of
// service operation instance methods, which may be assigned as a property
// of the ResourceManager constructor.
// The resulting static operation method will create a new instance of the
// manager, execute the specified operation, and return a reference to the
// new instance.
// ``operation``: String, name of the instance service operation
Charon.defineStaticManagerOperation = function (operation) {
  return function (options, callback) {
    var instance = new this(options);
    return instance[operation](callback);
  }
};


// A predefined service callback wrapper function.
// Sets resource attributes on instance before returning.
Charon.setResourceManagerWrapper = function (wrapped, err, resource) {
  if (! err) {
    this.resource = resource;
  }
  return wrapped(err, resource);
};

// A service callback wrapper function factory.
// Creates a callback wrapper function which creates one or more manager
// instances from a resource attribute, and assigns the manager instance(s)
// to a property on the manager instance with the name of the attribute name.
// Parameters:
// ``relationships``: Object, map of related data attribute names to
//                    ResourceManager constructors.
// Example of creating a resource containing a collection of other resources:
//    MyClient.MyResourceListManager = Charon.ResourceManager.extend({
//      buildUrl: function () { return '/resource/list'; }
//      get: Charon.defineManagerOperation({
//        name: "get",
//        method: "GET",
//        wrappers: [
//          Charon.setResourceManagerWrapper,
//          // build a list of related ``MyResourceManager`` instances from
//          // ``resource.items``, and assign to the ``manager.items``
//          // instance property: 
//          Charon.buildSetRelatedWrapper({
//            items: MyClient.MyResourceManager
//          })
//        ]
//      })
//    });
Charon.buildSetRelatedWrapper = function (relationships) {
  return function (wrapped, err, resource) {
    if (! err) {
      _.each(relationships, function (ResourceManager, attrName) {
        var makeResourceManager = function (resourceData) {
          return new ResourceManager(resourceData);
        }
        // support either array or scalar related data:
        var relatedData = resource[attrName];
        if (_.isArray(relatedData)) {
          this[attrName] = _.map(relatedData, makeResourceManager);
        }
        else {
          this[attrName] = makeResourceManager(relatedData);
        }
      }, this);
    }
    return wrapped(err, resource);
  };
};

// Creates a ``ResourceManager`` instance encapsulating a resource and
// service operations, enacted via requests to one or more ReST services.
Charon.ResourceManager = extend.call(Function, {

    constructor: function CharonResourceManager (options) {
      this.client = this.constructor.client;
      if (! this.client) {
        throw new TypeError('Charon.ResourceManager definition must be ' +
          'a member of a Charon.Client instance.');
      }
      this.initialize(options);
    },

    // ``options`` object param may include resource data and any other
    // information necessary to make the service request, such as an auth token
    // or search query.
    // May be overridden by the integrator.
    // Note, as a general guiding principle, options should be used to store
    // data which is needed to make requests pertaining to the resource, but
    // not part of the resource itself, such as paging parameters. Data which
    // is technically necessary for the request but which is not related to the
    // resource, such as an API token, would ideally be stored in the client.
    // Conversely, data which is integral to the resource, such as an ID,
    // should be stored directly within the resource and not as an option.
    // Storing resource attributes in two places raises the possibility of a
    // conflict.
    initialize: function (options) {
      options || (options = {});
      this.options = _.omit(options, 'resource');
      this.resource = options.resource || {};
    },

    // Creates and returns a request specification object.
    // A request specification object contains the following fields:
    //  - ``url`` (string): a fully qualified Uniform Resource Locator
    //  - ``method`` (string): an HTTP method (e.g., "GET")
    //  - ``headers`` (object): a map of header field names to values
    //  - ``body`` (object): a JSON-serializable request entity object
    // The integrator may override this method, but in most cases it will
    // be sufficient to override one of the more finely-grained
    // `build<Component>`` methods.
    buildRequestSpec: function (options) {
      // unpack args
      options || (options = {});
      // end unpack args
      var requestSpec = {};
      // add ``requestSpec`` reference to options passed to component builders
      var subOptions = _.extend({}, options, { requestSpec: requestSpec });
      
      // Note, the order of these operations is important
      requestSpec.method = this.buildMethod(subOptions);
      requestSpec.url = this.buildUrl(subOptions);
      requestSpec.headers = this.buildHeaders(subOptions);
      requestSpec.body = this.buildBody(subOptions);
      return requestSpec;
    },

    defaultMethod: "GET",

    // may be overriden by integrator
    buildMethod: function (options) {
      return options.method || defaultMethod;
    },

    // must be overriden by integrator
    buildUrl: function (options) {
      throw new TypeError("Not Implemented");
    },

    // may be overridden by integrator
    buildHeaders: function (options) { return undefined; },
  
    entityMethods: ["PUT", "POST", "OPTIONS"],

    // may be overridden by integrator
    buildBody: function (options) {
      if (this.entityMethods.indexOf(options.requestSpec.method) !== -1) {
        return this.resource;
      }
      return undefined;
    },

    // A Request-lib specific adapter. May be overridden by the integrator
    // to use a different network communication lib. Responsible for invoking
    // the callback with the following params:
    //  - err: a CharonError instance or null/undefined
    //  - responseSpec: a normalized response specification object. Should
    //                  contain the following properties:
    //    - statusCode: the HTTP status code
    //    - body: the response entity.
    //    - headers: the response headers
    //    - requestSpec: the request specification object
    submitRequest: function (requestSpec, callback) {
      request({
        json: requestSpec.body || true,
        url: requestSpec.url,
        method: requestSpec.method,
        headers: requestSpec.headers
      }, function (err, response, body) {
        var callbackErr, responseSpec;
        if (err) { 
          callbackErr = new Charon.RuntimeError('HTTP client error', {
            err: err,
            requestSpec: requestSpec
          });
        }
        else {
          responseSpec = {
            body: body,
            statusCode: response.statusCode,
            headers: response.headers,
            requestSpec: requestSpec
          };
        }
        callback(callbackErr, responseSpec);
      });
    },

    // A network-communication-library-agnostic response processing layer.
    // Creates a function responsible for processing the given CharonError
    // instance / response specification object pair, and in turn either
    // invoking the given callback with a CharonError instance, or passing
    // the responseSpec to a resource extraction method.
    // This method is primarily useful as a generic handler for HTTP
    // status codes and should not need to be overridden for most general
    // integration needs.
    responseHandlerFactory: function (callback) {
      return _.bind(function (err, responseSpec) {
        var callbackErr;
        if (err) {
          this.client.log('error', 'HTTP Client software error', err);
          callbackErr = err;
        }
        else {
          var status = responseSpec.statusCode;
          if (status == 403) {
            callbackErr = new Charon.RequestForbiddenError(responseSpec);
          }
          else if (status == 404) {
            callbackErr = new Charon.ResourceNotFoundError(responseSpec);
          }
          else if (status == 409) {
            callbackErr = new Charon.ResourceConflictError(responseSpec);
          }
          else if (status >= 400 && status <= 499) {
            // 4xx error
            callbackErr = new Charon.ConsumerError(responseSpec);
          }
          else if (status >= 500 && status <= 599) {
            // 5xx error
            callbackErr = new Charon.ServiceError(responseSpec);
            this.client.log('error', '5xx Service Error', responseSpec);
          }
          else if (status >= 200 && status <= 299) {
            // success
            return this.parseResource(responseSpec, callback);
          }
          else { // not sure what this is
            callbackErr = new Charon.RuntimeError('Unrecognized HTTP status code', responseSpec);
            this.client.log('error', 'Unrecognized HTTP status code', responseSpec);
          }
        }
        return callback(callbackErr);
      }, this);
    },

    // Responsible for parsing the normalized response specification object
    // into a resource object and invoking the callback with ``err``,
    // ``resource`` args. Unlike ``responseHandlerFactory``, this method is
    // concerned with the body and not with metadata.
    // This method may be overridden by the integrator.
    parseResource: function (responseSpec, callback) {
      return callback(null, responseSpec.body);
    }

  }, {
    isCharonResourceManagerConstructor: true
  }
);

// An example/template of a manager definition with several basic CRUD service
// operations (get, save, and delete).
Charon.CrudResourceManager = Charon.ResourceManager.extend({
  get: Charon.defineManagerOperation({
    name: "get",
    method: "GET",
    wrappers: [ Charon.setResourceManagerWrapper ]
  }),
  save: Charon.defineManagerOperation({
    name: "save",
    method: "PUT",
    wrappers: [ Charon.setResourceManagerWrapper ]
  }),
  "delete": Charon.defineManagerOperation({
    name: "delete",
    method: "DELETE"
  })
}, {
  // "static" get and delete methods:
  get: Charon.defineStaticManagerOperation("get"),
  "delete": Charon.defineStaticManagerOperation("delete")
});
